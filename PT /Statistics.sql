sqlplus / as sysdba

SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED,stale_stats  FROM DBA_TAB_STATISTICS WHERE OWNER='SOE' AND TABLE_NAME='EMP';

CREATE TABLE SOE.EMP3 AS SELECT * FROM SOE.EMP;

SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED,stale_stats FROM DBA_TAB_STATISTICS WHERE OWNER='SOE' AND TABLE_NAME='EMP3';
--stats automatically gather when we create a table using create as select statement

DROP TABLE SOE.EMP3 PURGE;

=== Manual creation of table ===

CREATE TABLE SOE.EMP3 ( 
EMP_NO  NUMBER(4),
ENAME  VARCHAR2(20),    
HIRE_DATE  DATE, 
DEPT_NO  NUMBER(2),    
JOB_CODE  CHAR(4), 
SALARY  NUMBER(8,2),    
MGR_ID  NUMBER(4), 
TERMINATED  CHAR(1), 
NOTES  VARCHAR2(1000));

SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED,stale_stats FROM DBA_TAB_STATISTICS WHERE OWNER='SOE' AND TABLE_NAME='EMP3';

SET LINESIZE 180
SET AUTOT TRACE EXP 
SELECT * FROM SOE.EMP3 WHERE EMP_NO=641;

SET AUTOT OFF
SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED FROM DBA_TAB_STATISTICS WHERE OWNER='SOE' AND TABLE_NAME='EMP3';

INSERT INTO SOE.EMP3 SELECT * FROM SOE.EMP;
COMMIT;

SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED FROM DBA_TAB_STATISTICS WHERE OWNER='SOE' AND TABLE_NAME='EMP3';

CREATE UNIQUE INDEX SOE.EMP3_EMPNO_UQ   ON SOE.EMP3(EMP_NO) NOLOGGING TABLESPACE SOETBS;

SELECT BLEVEL, LEAF_BLOCKS AS "LEAFBLK", DISTINCT_KEYS AS "DIST_KEY",AVG_LEAF_BLOCKS_PER_KEY AS "LEAFBLK_PER_KEY",AVG_DATA_BLOCKS_PER_KEY AS "DATABLK_PER_KEY"FROM DBA_IND_STATISTICS WHERE OWNER = 'SOE' AND INDEX_NAME = 'EMP3_EMPNO_UQ';   

-- Index statistics gathered when we create index on it

SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED FROM DBA_TAB_STATISTICS WHERE OWNER='SOE' AND TABLE_NAME='EMP3';
--  stats are not gathered on table inspite of  creating an index 


SET LINESIZE 180
SET AUTOT TRACE EXP 
SELECT * FROM SOE.EMP3 WHERE EMP_NO=641;  -- Index utilized

analyze table SOE.EMP3 compute statistics; -- till 11g

analyze table SOE.EMP3 estimate statistics; -- from 12c 

SELECT * FROM SOE.EMP3 WHERE EMP_NO=641;  -- compare explain plan

DROP TABLE SOE.EMP3;
exit;
=======================
INDEX CLUSTERING FACTOR:
=======================

conn / as sysdba
CREATE INDEX SOE.EMP_ENAME_IX ON SOE.EMP(ENAME) --Already Exists;  

SELECT BLEVEL, LEAF_BLOCKS, CLUSTERING_FACTOR FROM DBA_INDEXES WHERE OWNER='SOE' AND TABLE_NAME='EMP' AND INDEX_NAME= 'EMP_ENAME_IX'; 

CREATE TABLE SOE.EMP3 NOLOGGING AS SELECT * FROM SOE.EMP ORDER BY ENAME;

CREATE INDEX SOE.EMP3_ENAME_IX ON SOE.EMP3(ENAME);

SELECT blevel, leaf_blocks, clustering_factor FROM DBA_indexes WHERE OWNER='SOE' AND table_name='EMP3' AND index_name= 'EMP3_ENAME_IX';  -- Clustering factor is low


SET AUTOT TRACE EXP; 
SELECT * FROM SOE.EMP WHERE ENAME BETWEEN 'AOZLA PACUS' AND 'BAFD PZLCL';

SET AUTOT TRACE EXP; 
SELECT * FROM SOE.EMP3 WHERE ENAME BETWEEN 'AOZLA PACUS' AND 'BAFD PZLCL';

--The table EMP3 has the same data as the original EMP table, but the index on EMP3 has a much lower clustering factor. This is because, Data in the table is ordered by the ENAME.

--The higher the Index Clustering Factor of an index, the more expensive it is for an optimizer to use the index

=========================================
Gathering Optimizer Statistics Manually
=========================================

conn soe/soe

CREATE TABLE soe.ORDERS2 
( ORDER_ID  NUMBER(12), 
ORDER_DATE    TIMESTAMP(6) WITH LOCAL TIME ZONE, 
ORDER_MODE    VARCHAR2(8), 
CUSTOMER_ID   NUMBER(12), 
ORDER_STATUS  NUMBER(2), 
ORDER_TOTAL   NUMBER(8,2), 
SALES_REP_ID  NUMBER(6), 
NOTES VARCHAR2(15));

SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED FROM USER_TAB_STATISTICS WHERE TABLE_NAME='ORDERS2';

SET AUTOT OFF

INSERT INTO ORDERS2 SELECT ORDER_ID, ORDER_DATE, ORDER_MODE, CUSTOMER_ID, ORDER_STATUS, ORDER_TOTAL, SALES_REP_ID, DBMS_RANDOM.STRING('a',ROUND(DBMS_RANDOM.VALUE(5,15))) FROM ORDERS fetch first 40000 rows only;

COMMIT;

SELECT NUM_ROWS, BLOCKS, LAST_ANALYZED FROM USER_TAB_STATISTICS WHERE TABLE_NAME='ORDERS2';

exec DBMS_STATS.GATHER_TABLE_STATS(OWNNAME=>'SOE', TABNAME=>'ORDERS2'); 

SELECT NUM_ROWS, BLOCKS,STALE_STATS, LAST_ANALYZED  FROM USER_TAB_STATISTICS WHERE TABLE_NAME='ORDERS2';

DELETE ORDERS2 WHERE MOD(ORDER_ID,2)=0;
COMMIT;

SELECT NUM_ROWS, BLOCKS,STALE_STATS, LAST_ANALYZED  FROM USER_TAB_STATISTICS WHERE TABLE_NAME='ORDERS2';


set autotrace traceonly;
SELECT * FROM ORDERS2 WHERE ORDER_ID BETWEEN 60000 AND 80000; 

-- diff between rows fetched and explain plan rows fetched

set autot off

exec DBMS_STATS.GATHER_TABLE_STATS(OWNNAME=>'SOE', TABNAME=>'ORDERS2');

SELECT NUM_ROWS, BLOCKS,STALE_STATS, LAST_ANALYZED  FROM user_TAB_STATISTICS WHERE TABLE_NAME='ORDERS2';


set autot on 

SELECT * FROM ORDERS2 WHERE ORDER_ID BETWEEN 60000 AND 80000; 
 
set autot off; 
  
DROP TABLE ORDERS2 purge;
 
CREATE TABLE ORDERS2 AS SELECT ORDER_ID, ORDER_DATE, ORDER_MODE, CUSTOMER_ID, ORDER_STATUS, ORDER_TOTAL, SALES_REP_ID, DBMS_RANDOM.STRING('a',ROUND(DBMS_RANDOM.VALUE(5,15))) NOTES FROM ORDERS  WHERE ORDER_ID BETWEEN 10    AND   50000 ORDER BY CUSTOMER_ID;
 
CREATE INDEX ORDERS2_ORD_ID ON ORDERS2(ORDER_ID);
 
 
SELECT LEAF_BLOCKS, BLEVEL, LEAF_BLOCKS, DISTINCT_KEYS, CLUSTERING_FACTOR, NUM_ROWS FROM USER_INDEXES WHERE INDEX_NAME='ORDERS2_ORD_ID';

--The clustering factor is very close to the number of rows which will result in high cost.
 
 
 set linesize 180
 set autot on exp
 
 SELECT * FROM ORDERS2 WHERE ORDER_ID < 10100;  ---FTS because of High clustering FACTOR 
 
 set autot off

DROP TABLE ORDERS2 purge;

CREATE TABLE ORDERS2 AS SELECT ORDER_ID, ORDER_DATE, ORDER_MODE, CUSTOMER_ID, ORDER_STATUS, ORDER_TOTAL, SALES_REP_ID, DBMS_RANDOM.STRING('a',ROUND(DBMS_RANDOM.VALUE(5,15))) NOTES FROM ORDERS  WHERE ORDER_ID BETWEEN 10 AND 50000 ORDER BY ORDER_ID;

CREATE INDEX ORDERS2_ORD_ID ON ORDERS2(ORDER_ID);

SELECT LEAF_BLOCKS, BLEVEL, LEAF_BLOCKS, DISTINCT_KEYS, CLUSTERING_FACTOR, NUM_ROWS FROM USER_INDEXES WHERE INDEX_NAME='ORDERS2_ORD_ID';

set autot on exp

SELECT * FROM ORDERS2 WHERE ORDER_ID <10100;  -- as clustering factor is low it has taken index range scan


set autot off

DROP TABLE ORDERS2;


Table:
======

EXEC DBMS_STATS.gather_table_stats('OWNER','TABLE_NAME');

EXEC DBMS_STATS.gather_table_stats('OWNER','TABLE_NAME',cascade=>TRUE);
---Cascade will gather Index stats associated with the table

Index:
======
EXEC DBMS_STATS.gather_index_stats('OWNER','INDEX_NAME');

Schema:
=======

EXEC DBMS_STATS.gather_schema_stats('SCHEMANAME');

Database:
=========

EXEC DBMS_STATS.gather_database_stats;

System and fixed objects:
=========================

EXEC DBMS_STATS.gather_dictionary_stats;

EXEC DBMS_STATS.gather_system_stats;

EXEC DBMS_STATS.gather_fixed_objects_stats;

DBMS_STATS.GATHER_TABLE_STATS
(
ownname => 'PROD', 
tabname =>'&name', 
ESTIMATE_PERCENT => 100,
METHOD_OPT => 'FOR ALL COLUMNS SIZE AUTO', 
CASCADE => TRUE,
DEGREE => 5);
